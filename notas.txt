- git rm --cached nombre_archivo.extencion -> se usa cuando por ejm hacemos un add de un archivo y cuando esta en verde queremos sacarlo de los adds- 

- git config --list (configuracion por defecto)
- git config --list --show-origin (ver donde estan las configuraciones guardadas)
- git config --global user.name (configuracion del usuario de git)
- git config --global user.email (configuracion del email de git)

- git log nombre_archivo.extension (muestra el historico del archivo)

- git show archivo.extension (cambios que han existido en un archivo)

- git commit (sin mensaje, escribimos el mensaje, y para salir del vim, apretamos Esc + shift + z + z)
para escribir texto en vim, presionamos Esc + i

- Si queremos agregar comentarios en VIM, la primera linea seria el titulo y si das doble enter, el resto seria la descripcion de ese commit, y las lineas con # son comentarios, y no se pueden enviar commits vacios de mensajes

- git diff (para ver las diferencias entre un cmabio y otro, para esto hay q copiar los hash que te salen cuando haces un git log al lado de la palabra commit. Se compara entre versiones, por ende debes ingresar dos hash o codigos de commit para poder compararlos, ejm git diff 9014c67cd2587fe530ba1948887fd454144786e4 d90c2a4df958f3c960773ebd77060e26368d8a81, donde el primer hash es el ultimo cambio y el segundo hash fue el primer commit para este archivo, si cambias el orden y colocas el hash mas viejo de primero y el hash mas reciente de ultimo, cambia la manera en q se muestran los cambios, y te va mostrar en verde los cambios mas recientes y en rojo lo q estaba antes en el commit viejo )

- Branches:
    * git reset, volvemos a una version anterior
        + git reset id_del_commit --soft ó --hard 
            ~ soft (volvemos al estado del commit, pero si hay algo en el staging sigue ahi, es decir, si se hizo un cmabio y se hizo git add,e ste no se elimina).
            ~ hard (todo vuelve al estado que tenia el commit)
        + git reset HEAD: Este es el comando para sacar archivos del área de Staging. No para borrarlos ni nada de eso, solo para que los últimos cambios de estos archivos no se envíen al último commit, a menos que cambiemos de opinión y los incluyamos de nuevo en staging con git add, por supuesto.

    * para ver el archivo como estaba en un commit especifico, solo hacemos un git checkout id_commit _nombre_archivo
        + git checkout d90c2a4df958f3c960773ebd77060e26368d8a81 historia.txt.
        + si no guardamos o si no hacemos un add, para volver a la version que esta en master, es decir la ultima guardada y mergeada con master, volvemos a como estaba.
        + git checkout master historia.txt
        + se puede ir hasta una version especifica, hacer cambios y luego hacer un add + commit y se guarada una nueva version de los archivos que se toquen, pero hay q tener cuidado con esto.
    
- git rm: Este comando nos ayuda a eliminar archivos de Git sin eliminar su historial del sistema de versiones. Esto quiere decir que si necesitamos recuperar el archivo solo debemos “viajar en el tiempo” y recuperar el último commit antes de borrar el archivo en cuestión.
    * git rm --cached: Elimina los archivos del área de Staging y del próximo commit pero los mantiene en nuestro disco duro.
    * git rm --force: Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder al registro de la existencia de los archivos, de modo que podremos recuperarlos si es necesario (pero debemos usar comandos más avanzados).

- git reset: Este comando nos ayuda a volver en el tiempo. Pero no como git checkout que nos deja ir, mirar, pasear y volver. Con git reset volvemos al pasado sin la posibilidad de volver al futuro. Borramos la historia y la debemos sobreescribir. No hay vuelta atrás.

- git commit -am "mensaje", haces un git add y git commit a la vez, pero para hacerlo ya debiste haber hecho add de este archivo anteriormente.

- merge:
  * siempre se hace desde la rama donde estoy, por eso debe hacerse desde el master, hacemos un git merge rama_a_mergear
  * si despues de mergear lo q se commiteo desde una nombre_rama a master, vas a la rama nombre_rama y haces un merge de lo que esta en master, y te vas a traer los cambios ya fusionados que estan en master al branch nombre_rama.

- conflictos
  * <<<<<<< HEAD -> te dice que el codigo en esa seccion, es como lo tienes en la rama actual, es decir en MASTER, si estas haciendo el merge de otra branch hacia master.
  * >>>>>>> cabecera -> quiere decir que el codigo encima de esto, es lo que tienes en la rama que quieres mergear, en este caso nombre_rama, que quieres fusionar hacia master.

- github
  * copiamos el http del repositorio
  * le decimos a git que vamos a conectarnos con un repositorio remoto
    + git remote add origin link_http_del_repositorio
      ~ git remote -> vemos origin que es donde esta conectado el repositorio remoto
      ~ git remote -v -> nos muestra los repositorios para fetch (traernos codigo) y push (enviar codigo)
      ~ git pull origin main -> primero te traes todo lo que esta en el repositorio remoto
      ~ git push origin main -> al conectar con nuestro repositorio remoto, solo tenemos que enviar el codigo local
      ~ git pull origin master --allow-unrelated-histories -> cuando presente el error "fatal: refusing to merge enrelated histories" con esto forzamos a hacer pull del remoto fusionandola con la rama local, caso super aislado y como se crean primeros archivos.

- LLaves publicas y privadas
  * Antes que nada hay que ubicarse en el home del computador, debes abrir el bash de git (terminal), y ubicarte en la carpeta raiz, en el caso de windows seria c:/Users/nombre_usuario
  * Configurar llaves SSH local
    + en entorno local se crea una llave privada y una llave publica
    + luego se envia a github la llave publica
    + se conecta por un nuevo protocolo, en vez de https, se conecta por SSH (Secure Shell)
    + Automaticamente Github te envia su propia llave publica a tu entorno local, ambos tienen sus llaves publicas y ya estan conectados via SSH, y por ende conectarse sin logearse constantemente
    + para crear la llave, hay q hacerlo en el home de tu computador, seria el lugar desde donde normalmente guardas tus proyectos, en windows suele ser en el disco C:/Users/Tu_Usuario, en mac, /Users/Tu_Usuario.
    + para ver la configuracion de git en local, ejecutas en la terminal el comando git config -l para ver tus datos
    + para cambiar el email de tu cuenta, git config --global user.email "tu_email@correo.com"
    + Creamos la llave SSH
      ~ ssh-keygen -t rsa -b 4096 -C "tucorreo@correo.com" enter
        # el correo debe ser el que tienes registrado en el repositorio, en este caso github
        # -t indica el algoritmo, q es el rsa, 
        # -b es lo complejidad de la llave
        # -C es el correo electronico al que se va a conectar el repo
      ~ te dice donde va generar la clave, siempre dar enter de nuevo.
      ~ Pide un phassphrase, por lo general y seguridad lo mejor es colocarla
      ~ te deja un mensaje en consola de que esta generandose la llave public/privada, y te pide un password:
        # Ejm: Enter file in which to save the key (/Users/usuario/.ssh/id_rsa):
        # como se ve en el caso de mac se crea la carpeta .ssh en el directorio con tu nombre de usuario
      ~ luego te pide un passphrase, password con espacios, clave adicional de texto para agregarle a tu llave, puedes agregarla o no.
      ~ y listo se generaron las claves.
    + hay que llevar la llave a github, (en mac hay q llevar la clave al entorno)
      ~ linux/windows hay q revisar que el servidor de llaves ssh este prendido.
        # eval $(ssh-agent -s)
        # la respuesta en consola, seria algo como: Agent pid 1234
        # agregamos la llave al servidor
          > se ejecuta el comendo: ~/.ssh
          > ls -al y vemos las llaves creadas
          > ssh-add ~/.ssh/id_rsa, respuesta: identity added: ruta_de_la_clave
      ~ mac
        # se crea una carpeta dentro del directorio .ssh que se creo en el home, con el nombre known_hosts
        # si se hace un: cat id_rsa.pub abres el contenido de tu llave publica
        # si haces: cat known_hosts, tambien te sale un monton de codigo ilegible
        # hay q evaluar si esta corriendo el ss-agent
          ~ eval "$(ssh-agent -s)" -> y la respuesta seria: Agent pid 1234
        # si se usa una version reciente del sistema operativo MAC hay q editar o crear un archivo llamado config.
        # para ver los archivos q estan en la carpeta .ssh, ingresamos el comando ls -al, por lo general no existe este archivo por que estamos creando la clave nueva, osea no teniamos clave ssh anteriormente.
          ~ vim config y se crea el archivo
          ~ presionamos Esc + i para escribir el archivo de texto
          ~ ingresamos el siguiente codigo tal cual (incluyendo los tags):
            Host *
              AddKeysToAgent yes
              UseKeychain yes
              IdentityFile ~/.ssh/id_rsa
          ~ guardamos usando Esc + shift + zz
          ~ para ver el contenido del archivo ejecutamos, cat config, y sale el texto que escribimos.
        # ejecutamos ssh-add -K ~/.ssh/id_rsa, respuesta: identity added: ruta_de_la_clave
          ~ la -K es para la keygen una clave q necesita mac
    + Conexion a github con SSH
      ~ hay que crear una llave publica y una llave privada por cada conexion (maquina) que conectes a tu repositorio.
      ~ copiamos nuestra clave publica del archivo id_rsa.pub
      ~ vamos a github, click en el menu arriba a la derecha, y click en settings, luego click en el menu izquierdo en "SSH and GPG Keys".
      ~ Click en New SSH Key
        # Se agraga un titulo, y se pega la clave publico en el textarea con label "KEY"
        # Te pide contraseña de github para guardar, la ingresas y listo, hemos agregado nuestra maquina a la conexion con SSH.
      ~ Vamos al repositorio que queremos usar con ssh, en el caso del curso, el repo Hiperblog y copiamos en el boton para clonar, la direccion ssh del repo.
      ~ En la terminal vamos a la carpeta donde tenemos el proyecto para conectarnos a traves de ssh al repo en github
      ~ git remote -v (nos muestra la url del repositorio), vamos a cambiar esa url
      ~ git remote set-url origin git@github.com:juanluisoropeza/hiperblog.git
        # basicamente cambiamos la URL del origin que configuramos antes por la URL que acabamos de copiar en el repositorio en el apartado SSH. Esto habilita la conexion ssh y ya podemostrabajar.
      ~ Lo primero que se hace antes de hacer un commit, es traernos la ultima version de lo que tenemos en el repo remoto.
      ~ hacemos un git pull en la terminal, y en pantalla va a aparecer una validacion de si quiere autorizar la conexion con el RSA Key. solo hay que escribir yes y darle enter.
      ~ Luego pide la passphrase que creamos al configurar la conexion ssh, se ingresa y se de enter, y listo, debe aparecer un mensaje como "Already up to date".
      ~ Luego volvemos a escribir git pull origin master, y de haber cambios, te va a traer los cambios a tu repo local.
      ~ para subir nuevos cambios, hacemos un commit, y antes de subirlos hacemos un pull de origin master.

- Tags y Versiones en git y github
  * ver el historial de nuestro proyecto
    + git log
    + git log --all (todos los cambios historicos)
    + git log --all --graph (se ve graficamente la union de mezcla de ramas o branchs)
    + git log --all --graph --decorate --oneline (muestra todo comprimido y grafico)
  * Agregar un alias a un comando
    + alias arbolito=git log --all --graph --decorate --oneline
    + para ejecutarlo solo ejecutamos en la terminal el alias que agregamos, en este caso: arbolito + enter 
  * Crear un tag
    + lo primero es copiar un hash del commit, esto es mostrado con el git log
      ~ git tag -a v0.1 -m "resultado de las primeras clases del curso" nro_hash
      ~ git tag -> lista de todos los tags
      ~ git show-ref --tags -> muestra el tag asignado al commit en detalle
    + enviar tag a github (repo remoto)
      ~ git pull origin main (o master, dependiendo del repo).
      ~ git push origin --tags
    + Borrar Tags
      ~ git tag -d nombre_tag
      ~ git pull origin main
      ~ git push origin --tags
      ~ NOTA: automaticamente no se borra en el repo remoto (github), esto es por que los tags pueden utilizarse como releases, para borrarlo en el repo remoto, hay que hacer otro paso:
      ~ git push origin :refs/tags/nombre_tag

- Branches (Ramas)
  * git show-branch -> nos muestra las ramas existentes y su historia
  * git show-branch --all -> muestra lo mismo pero con mas detalle
  * gitk -> abre la historia visualmente del repo
  * git push origin rama y se suben los cambios a de la rama en local, al repositorio remoto
  * Para agregar colaboradores a un repositorio github, se debe ir a los settings del repo, luego a Collaborators en el sidebar, y se debe agregar el correo del colaborador o su nombre de usuario.
  * si despues de hacer un pull, se trae cambios desde master o main, que hizo algun otro programador, y hacemos un got log --stat veremos el detalle en los commits subidos.
  
- Pull Request -> es un estado intermedio antes de enviar el merge.
  * 





